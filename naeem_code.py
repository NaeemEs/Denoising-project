# -*- coding: utf-8 -*-
"""Naeem_Code

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pml93-ncBlp2vX_O_gBlIrcRO2_3neYz
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.ndimage import gaussian_filter, laplace, sobel
from scipy.ndimage import gaussian_laplace
from skimage import io, img_as_float
from skimage.util import random_noise

def perona_malik_diffusivity(grad_mag, lambda_val):
    return 1 / (1 + (grad_mag ** 2 / lambda_val ** 2))

def compute_gradients_periodic(u):
    fx = sobel(u, axis=0)
    fy = sobel(u, axis=1)
    return fx, fy

def compute_laplacian_periodic(u):
    lap = laplace(u)
    return lap

def apply_periodic_boundary(u):
    u[0, :] = u[-2, :]
    u[-1, :] = u[1, :]
    u[:, 0] = u[:, -2]
    u[:, -1] = u[:, 1]
    return u

def diffusion_solver_periodic(I, lambda_val, num_iter, dt):
    u = I.copy()
    for _ in range(num_iter):
        fx, fy = compute_gradients_periodic(u)
        grad_mag = np.sqrt(fx ** 2 + fy ** 2)
        D = perona_malik_diffusivity(grad_mag, lambda_val)
        laplacian = compute_laplacian_periodic(u)
        u += dt * (laplacian * D)
        u = apply_periodic_boundary(u)
    return u

def diffuse_image(I, d, dt, dx, dy, num_steps):
    u = I.copy()
    for _ in range(num_steps):
        u_new = u.copy()
        u_new[1:-1, 1:-1] = u[1:-1, 1:-1] + d * dt * (
            (u[2:, 1:-1] - 2 * u[1:-1, 1:-1] + u[:-2, 1:-1]) / dx**2 +
            (u[1:-1, 2:] - 2 * u[1:-1, 1:-1] + u[1:-1, :-2]) / dy**2
        )
        u_new[0, :] = 0
        u_new[-1, :] = 0
        u_new[:, 0] = 0
        u_new[:, -1] = 0
        u = u_new
    return u

# Load images
C_Image = img_as_float(io.imread('office.png'))
N_Image = img_as_float(io.imread('office_noisy.png'))

# Plot noisy and clear Office Image
plt.figure(figsize=(12, 6))
plt.subplot(1, 2, 1)
plt.imshow(C_Image, cmap='gray')
plt.title('Clear Image')

plt.subplot(1, 2, 2)
plt.imshow(N_Image, cmap='gray')
plt.title('Noisy Image')
plt.show()

# Apply Gaussian Smoothing
Sig = [0.5, 1, 2, 5, 10, 50]
plt.figure(figsize=(12, 8))
for i, sigma in enumerate(Sig):
    G_Image = gaussian_filter(N_Image, sigma)
    plt.subplot(2, 3, i+1)
    plt.imshow(G_Image, cmap='gray')
    plt.title(f'σ = {sigma}')
plt.tight_layout()
plt.show()

# Plot 3D Gaussian Kernels
from mpl_toolkits.mplot3d import Axes3D

plt.figure(figsize=(12, 8))
for i, sigma in enumerate(Sig):
    kernel_size = int(6 * sigma + 1)
    half_size = kernel_size // 2
    X, Y = np.meshgrid(np.arange(-half_size, half_size+1), np.arange(-half_size, half_size+1))
    gaussian_kernel = np.exp(-(X**2 + Y**2) / (2 * sigma**2))
    gaussian_kernel /= np.sum(gaussian_kernel)

    ax = plt.subplot(2, 3, i+1, projection='3d')
    ax.plot_surface(X, Y, gaussian_kernel, cmap='jet')
    ax.set_title(f'σ = {sigma}')
    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Amplitude')
plt.tight_layout()
plt.show()

# Apply linear diffusion filter
dx = dy = 1
dt = 0.1
d = 1
times = [1, 5, 10, 30, 100]

plt.figure(figsize=(12, 8))
plt.subplot(2, 3, 1)
plt.imshow(N_Image, cmap='gray')
plt.title('Original Image')

for k, t in enumerate(times):
    num_steps = int(t / dt)
    u = diffuse_image(N_Image, d, dt, dx, dy, num_steps)
    plt.subplot(2, 3, k+2)
    plt.imshow(u, cmap='gray')
    plt.title(f't = {t}')
plt.tight_layout()
plt.show()

diffusivities = [1, 5, 10]
t = times[2]  # t = 10
num_steps = int(t / dt)

plt.figure(figsize=(8, 6))
plt.subplot(2, 2, 1)
plt.imshow(N_Image, cmap='gray')
plt.title('Original Image')

for k, d in enumerate(diffusivities):
    u = diffuse_image(N_Image, d, dt, dx, dy, num_steps)
    plt.subplot(2, 2, k+2)
    plt.imshow(u, cmap='gray')
    plt.title(f'd = {d}')
plt.tight_layout()
plt.show()

# Evaluate Gaussian smoothing with σ = √2t
t = 2
sigma = np.sqrt(2 * t)
d = 1
num_steps1 = int(t / dt)
u = diffuse_image(N_Image, d, dt, dx, dy, num_steps1)
G = gaussian_filter(N_Image, sigma)

plt.figure(figsize=(8, 4))
plt.subplot(1, 2, 1)
plt.imshow(u, cmap='gray')
plt.title('d=1, t=2')

plt.subplot(1, 2, 2)
plt.imshow(G, cmap='gray')
plt.title(f'σ=√2t')
plt.show()

# Apply non-linear diffusion filter
lambda_values = [0.5, 1, 2, 5, 10]
numIterations = [1, 5, 10, 30, 100]

plt.figure(figsize=(12, 8))
plt.subplot(2, 3, 1)
plt.imshow(N_Image, cmap='gray')
plt.title('Original Image')

for i, numIter in enumerate(numIterations):
    u = diffusion_solver_periodic(N_Image, lambda_values[0], numIter, dt)
    plt.subplot(2, 3, i+2)
    plt.imshow(u, cmap='gray')
    plt.title(f't = {numIter}')
plt.tight_layout()
plt.show()

plt.figure(figsize=(12, 8))
plt.subplot(2, 3, 1)
I = img_as_float(io.imread('office.png'))
plt.imshow(I, cmap='gray')
plt.title('Original Image')

for i, numIter in enumerate(numIterations):
    u = diffusion_solver_periodic(I, lambda_values[0], numIter, dt)
    plt.subplot(2, 3, i+2)
    plt.imshow(u, cmap='gray')
    plt.title(f't = {numIter}')
plt.tight_layout()
plt.show()

plt.figure(figsize=(12, 8))
plt.subplot(2, 3, 1)
I = N_Image
plt.imshow(I, cmap='gray')
plt.title('Original Image')
dt=0.3
for i, lambda_val in enumerate(lambda_values):
    u = diffusion_solver_periodic(I, lambda_val, 10, dt)
    plt.subplot(2, 3, i+2)
    plt.imshow(u, cmap='gray')
    plt.title(f'λ = {lambda_val}')
plt.tight_layout()
plt.show()